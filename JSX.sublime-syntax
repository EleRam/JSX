%YAML 1.2
---
name: JSX
file_extensions: [jsx]
scope: source.js.jsx
variables:
  reservedWords: "(break|case|catch|class|const|continue|debugger|default|delete|do|else|export|extends|finally|for|function|from|if|import|in|instanceof|new|return|super|switch|this|throw|try|typeof|var|void|while|with|yield|enum|implements|interface|let|package|private|protected|public|static|await|abstract|boolean|byte|char|double|final|float|goto|int|long|native|short|synchronized|throws|transient|volatile)"
  typeWords: "(type|declare)"
  constantWords: "(true|false|null|Infinity|NaN|undefined)"
  tagStart: '<(?=\w)'
  validTypeSingle: '[\?\w\[\]\.\*]*(<.*?>)?'
  validType: '{{validTypeSingle}}(\s*\|\s*{{validTypeSingle}})*'
  typeParams: '(?<=:)\s*{{validType}}'
contexts:
  main:
    - include: jsx
    - include: javascript
  
  #
  # JSX
  # 
  
  jsx:
    - match: '{{tagStart}}'
      scope: entity.name.tag.jsx
      push: jsxSection
    - match: (?<=[\w\/])\>
      scope: entity.name.tag.jsx

  jsxSection:
    - meta_scope: meta.jsx
    - include: jsxTags


  jsxSectionInner: 
    - meta_scope: meta.jsx
    - include: jsxTags

  jsxTags:
    
    - include: strings
    
    - match: \b\w*\b
      scope: entity.name.tag.jsx

    - match: \=
      scope: entity.name.tag.jsx

    # Recursion
    - match: '{{tagStart}}'
      scope: entity.name.tag.jsx
      push: jsxSectionInner

    # Embedding
    - match: \{
      scope: entity.name.tag.jsx
      push: javascriptEmbedded
    
    # End
    - match: '<?\/\w*'
      scope: entity.name.tag.jsx
      pop: true

    - match: '>'
      scope: entity.name.tag.jsx
      push:
        - include: comments
        - match: \{
          scope: entity.name.tag.jsx
          push: javascriptEmbedded
        - match: (?=<)
          pop: true

  javascriptEmbedded:
    - clear_scopes: 1
    - meta_scope: source.js.jsx
    - include: jsx
    - include: javascript

    - match: '\{'
      push: jsEmbeddedInner

    - match: '\}'
      scope: entity.name.tag.jsx
      pop: true
  
  jsEmbeddedInner:
    - clear_scopes: 1
    - meta_scope: source.js.jsx
    - include: jsx
    - include: javascript

    - match: '\{'
      push: jsEmbeddedInner

    - match: '\}'
      pop: true
    
  #
  # JS
  # 
  
  javascript: 
    - include: types
    - include: keywords
    - include: constants
    - include: strings
    - include: comments
    # - include: bracketsGroup

  comments: 
    - scope: comment.block.jsx
      match: \{/\*
      push:
        - meta_scope: comment.block.jsx
        - match: \*/\}
          pop: true
    - scope: comment.block.js
      match: /\*
      push:
        - meta_scope: comment.block.js
        - match: \*/
          pop: true

    - scope: comment.line.js
      match: (//).*$\n?

  keywords:
    - match: '\b{{reservedWords}}\b'
      scope: keyword.control.js 
    # - match: '^\s*{{typeWords}}\s'
    - match: '^\s*{{typeWords}}\b(?![:])'
      scope: keyword.control.js

  constants:
    - match: '\b{{constantWords}}\b'
      scope: constant.language.js
    - match: >-
        (?xi)
          (?:\B[-+])?
          (?:
            \b0b[0-1]*|                 # binary
            \b0o[0-7]*|                 # octal
            \b0x[0-9a-f]*|              # hex
            (
              \B\.[0-9]+|               # e.g. .999
              \b[0-9]+(\.[0-9]*)?       # e.g. 999.999, 999. or 999
            )(e[-+]?[0-9]+)?            # e.g. e+123, E-123
          )
      scope: constant.numeric.js

  constantEntity:
    - match: (&[\w#]*?;)
      scope: constant.character.entity.html  

  constantEscape:
    - match: \\.
      scope: constant.character.escape

  strings: 
    - match: "'"
      push: stringSingle
    - match: "\""
      push: stringDouble
    - match: "`"
      push: stringTemplate
    - match: (?<=[=(:]|^|return|&&|\|\||!)\s*(/)(?![/*+{}?>])
      push: stringRegex

  stringSingle: 
    - meta_scope: string.quoted.js
    - include: constantEscape
    - include: constantEntity
    - match: "'"
      pop: true

  stringDouble: 
    - meta_scope: string.quoted.js
    - include: constantEscape
    - include: constantEntity
    - match: "\""
      pop: true

  stringRegex:
    - meta_scope: string.regexp.js
    - include: constantEscape
    - match: \[
      push: 
        - meta_scope: meta.regexpCharacterClass
        - include: constantEscape
        - match: \]
          pop: true
    - match: '/[gimuy]?'
      pop: true

  stringTemplate:
    - meta_scope: string.quoted.js
    - include: constantEscape
    - include: constantEntity
    - match: (?<=\${)
      push: templateExpressions
    - match: "`"
      pop: true

  templateExpressions:
    - clear_scopes: true
    - include: javascript
    - include: jsx
    - match: \}
      scope: string.quoted.js
      pop: true

  types: 
    - include: functionDeclarations
    - include: arrowFunctionDeclarations
    - include: classDeclaration

    # Variables
    - match: '(?<=const|let|var)(?:\s*\w*:\s*)({{validType}})\s*='
      captures:
        1: entity.name.type

    - match: '(?<=type|declare)\s*\w*\s*='
      push: typeDeclarations


    
    # class
  classDeclaration:
    - match: \bclass\b
      scope: keyword.control.js
      set:
        - include: main
        - match: (?<!\()\{
          set: classBody


  classBody: 
    - meta_scope: meta.classDeclaration.js
    - include: main
    - include: classBrackets

    - match: '^\s*\w+:\s*({{validType}})(?=;)'
      captures:
        1: entity.name.type

    - match: \w*\(
      push: 
        - meta_scope: meta.function.declaration
        - include: typeFunctionDeclaration
        - include: typeFunctionReturns
        - include: functionDeclarations
        - include: main
        - match: "(?={)"
          pop: true

    - match: "}"
      pop: true
  
  classBrackets:
    - match: "{"
      push: 
        - meta_scope: meta.classBrackets.js
        - match: "}"
          pop: true
        - include: classBrackets
        - include: main

  functionDeclarations:
    - match: '(?<=function)[\s\w]*(?=\()'
      push: 
        - meta_scope: meta.function.declaration
        - include: typeFunctionDeclaration
        - include: typeFunctionReturns
        - include: javascript
        - match: "{"
          pop: true

  arrowFunctionDeclarations:
    # opening bracket then word or ) any ammount of not )
    - match: '\((?=[\w\)].*=>)'
      push: 
        - meta_scope: meta.functionDeclaration.js
        - include: arrowFunctionDeclarations
        - include: typeFunctionDeclaration
        - include: typeFunctionReturns
        - include: javascript
        - match: "=>"
          pop: true

    
  
  typeFunctionDeclaration:
    - match: '(?<!return\ )\('
      push: 
        - meta_scope: meta.type.flowFunctionParams.js
        - include: javascript
        - match: '{{typeParams}}'
          scope: entity.name.type
        - match: '(?=\))'
          pop: true


  typeFunctionReturns:
    - meta_scope: meta.type.js
    - match: '{{typeParams}}'
      scope: entity.name.type
    - match: '{{typeParams}}\s(?={)'
      scope: entity.name.type

  typeDeclarations:
    - meta_scope: meta.type.js
    - include: arrowFunctionDeclarations
    - include: typeFunctionDeclaration
    - include: typeFunctionReturns

    - match: '{{typeParams}}'
      scope: entity.name.type
    - match: '{{validType}}(?=[;\n])'
      scope: entity.name.type
      
    - match: ';'
      pop: true
    - match: '}'
      pop: true


